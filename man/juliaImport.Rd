% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/importing.R
\name{juliaImport}
\alias{juliaImport}
\title{Load and import a Julia package via \code{import} statement}
\usage{
juliaImport(modulePath, all = TRUE)
}
\arguments{
\item{modulePath}{a module path or a module object.
A module path may simply be the name of a package but it may also
be a relative module path.
Specifying a relative Julia module path like \code{.MyModule}
allows importing a module that does not correspond to a package,
but has been loaded in the \code{Main} module, e. g. by
\code{juliaCall("include", "path/to/MyModule.jl")}.
Additionally, via a path such as \code{SomePkg.SubModule},
a submodule of a package can be imported.}

\item{all}{\code{logical} value, default \code{TRUE}.
Specifies whether all functions and types shall be imported
or only those exported explicitly.}
}
\value{
an environment containing all functions and type constructors
from the specified module as R functions
}
\description{
The specified package/module is loaded via \code{import} in Julia.
Its functions and type constructors are wrapped into R functions.
The return value is an environment containing all these R functions.
}
\note{
If a package or module contains functions or types with names that contain
non-ASCII characters, (additional) alternatives names are provided
if there are LaTeX-like names for the characters available in Julia.
In the alternative names of the variables, the LaTeX-like names of the
characters surrounded by \code{<...>} replace the original characters.
(See example below.)
For writing platform independent code, it is recommended to use those
alternative names.
(See also \link{JuliaConnectoR-package} under "Limitations".)
}
\examples{
if (juliaSetupOk()) {

   # Importing a package and using one of its exported functions
   UUIDs <- juliaImport("UUIDs")
   juliaCall("string", UUIDs$uuid4())


   # Importing a module without a package
   testModule <- system.file("examples", "TestModule1.jl",
                             package = "JuliaConnectoR")
   # take a look at the file
   writeLines(readLines(testModule))
   # load in Julia
   juliaCall("include", testModule)
   # import in R via relative module path
   TestModule1 <- juliaImport(".TestModule1")
   TestModule1$test1()
   \dontshow{
      JuliaConnectoR:::stopJulia()
   }
   # Importing a local module is also possible in one line,
   # by directly using the module object returned by "include".
   TestModule1 <- juliaImport(juliaCall("include", testModule))
   TestModule1$test1()


   # Importing a submodule
   testModule <- system.file("examples", "TestModule1.jl",
                             package = "JuliaConnectoR")
   juliaCall("include", testModule)
   # load sub-module via module path
   SubModule1 <- juliaImport(".TestModule1.SubModule1")
   # call function of submodule
   SubModule1$test2()


   # Functions using non-ASCII characters
   greekModule <- system.file("examples", "GreekModule.jl",
                             package = "JuliaConnectoR")
   suppressWarnings({ # importing gives a warning on non-UTF-8 locales
      GreekModule <- juliaImport(juliaCall("include", greekModule))
   })
   # take a look at the file
   cat(readLines(greekModule, encoding = "UTF-8"), sep = "\n")
   # use alternative names
   GreekModule$`<sigma>`(1)
   GreekModule$`log<sigma>`(1)
}

\dontshow{
JuliaConnectoR:::stopJulia()
}
}
